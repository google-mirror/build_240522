{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "92c7aa7e_d5ec830a",
        "filename": "core/packaging/flags.mk",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 1000701
      },
      "writtenOn": "2024-01-19T15:43:25Z",
      "side": 1,
      "message": "I don\u0027t understand the logic here. What does creating these files do?",
      "revId": "fb732b65601c760afe641a30f3e0a0ee25600493",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8feaacd1_f2c5a44d",
        "filename": "core/packaging/flags.mk",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 1882770
      },
      "writtenOn": "2024-01-19T15:48:05Z",
      "side": 1,
      "message": "If a partiton has no aconfig flags, then line 111 skips the aconfig storage creation command. Thus there will be no storage files created. However, we do need to have the empty files to show that there is no flag. These files are also in the `required_flag_files`, so if they don\u0027t exist, it will fail the copy rule, thus fail the build.",
      "parentUuid": "92c7aa7e_d5ec830a",
      "revId": "fb732b65601c760afe641a30f3e0a0ee25600493",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d04ca92_44cd05fd",
        "filename": "core/packaging/flags.mk",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 1000701
      },
      "writtenOn": "2024-01-19T15:55:28Z",
      "side": 1,
      "message": "Does the aconfig command on line 111-114 output multiple files? If so, would it be possible to invoke aconfig 3 times for the different files? It\u0027s much better to have the build rules be 1:1 with the commands. (Soong can handle multiple output files but Make can\u0027t).",
      "parentUuid": "8feaacd1_f2c5a44d",
      "revId": "fb732b65601c760afe641a30f3e0a0ee25600493",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6160853f_9c80690a",
        "filename": "core/packaging/flags.mk",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 1882770
      },
      "writtenOn": "2024-01-19T16:00:13Z",
      "side": 1,
      "message": "Yes, the aconfig command does emit 3 files. We can invoke it three times, one for each file. The issue was all these files based on the same intermediate sorted data. Right now, we only have to do processing once, then feed this intermediate data to each file serialization. Split it into 3 command means we need to do it 3 times. \n\nBut wouldn\u0027t current setup work for all 3 files. Just curious about the concern?",
      "parentUuid": "3d04ca92_44cd05fd",
      "revId": "fb732b65601c760afe641a30f3e0a0ee25600493",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1048bae5_7247750e",
        "filename": "core/packaging/flags.mk",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 1000701
      },
      "writtenOn": "2024-01-19T17:02:35Z",
      "side": 1,
      "message": "In this case, with this exact code I think it\u0027s fine actually because of the dependency of flag.val on $(1)/target.  There\u0027s a guaranteed ordering. But the problem is if that changes somehow, it\u0027s possible for the aconfig command to touch the file after the touch command. That\u0027ll make the dependency out of date the next time the build runs, and it\u0027ll redo the packaging steps after this, which actually are big, such as rebuilding the filesystem images.\n\nSo even though it\u0027s technically working, this is fragile and nobody will remember this detail. Aconfig is really fast, so I don\u0027t think it\u0027s worth trying to optimize it.  If this were like javac running on the framework we might think about hacking, but in this case the extra time won\u0027t be measurable, so it\u0027s better to do the clean thing.",
      "parentUuid": "6160853f_9c80690a",
      "revId": "fb732b65601c760afe641a30f3e0a0ee25600493",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5e5548a_72b993e7",
        "filename": "core/packaging/flags.mk",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 1882770
      },
      "writtenOn": "2024-01-19T17:16:20Z",
      "side": 1,
      "message": "Ack, created a bug to split the storage commands.",
      "parentUuid": "1048bae5_7247750e",
      "revId": "fb732b65601c760afe641a30f3e0a0ee25600493",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b748619c_334847c8",
        "filename": "core/packaging/flags.mk",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2024-01-19T19:05:28Z",
      "side": 1,
      "message": "Kati has .KATI_IMPLICIT_OUTPUTS, which allows 1 make rule to output multiple files.\nWe could use that instead of the separate rules, and only touch all the output files if `PRIVATE_IN` is empty.",
      "parentUuid": "e5e5548a_72b993e7",
      "revId": "fb732b65601c760afe641a30f3e0a0ee25600493",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}